# library(lattice) # histogram 加上lattice
hist(DMS$DMS)
means = mean(DMS$DMS)
std = sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)
lines(density(DMS$DMS, adjust=1),col = "red", lwd=2)
# histogram
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS)
means = mean(DMS$DMS)
std = sd(DMS$DMS)
curve(dnorm(DMS$DMS, mean=means, sd=std), col="blue", lwd=2, add=TRUE)
lines(density(DMS$DMS, adjust=1),col = "red", lwd=2)
# boxplot
hist(DMS$DMS)
means = mean(DMS$DMS)
std = sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
# boxplot
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
# boxplot
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
# boxplot
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
sd(DMS$DMS)
# boxplot
boxplot(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
sd(DMS$DMS)
# histogram
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
sd(DMS$DMS)
#a) Make a boxplot and histogram to verify that the distribution is roughly symmetric with no outliers.
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS,breaks = "Sturges")
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
sd(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS,breaks = 7)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
# histogram
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS,breaks = 7)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS,breaks = 7,ylim = range(breaks))
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
sd(DMS$DMS)
# boxplot
boxplot(DMS$DMS)
# histogram
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS,breaks = 7,ylim = range(0,1))
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS,freq = TRUE)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
# histogram
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
hist(DMS$DMS,freq = FALSE)
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
# possibilities for alternative are "two.sided" (confidence interval),
# "less" (upper confidence bound for one-sided test), "greater" (lower confidence bound for one-sided test)
t.test(DMS$DMS, conf.level=0.95, alternative = "two.sided")
#  b) Make a Normal quantile plot to confirm that there are no systematic departures from Normality.
quartz()
qqnorm(DMS$DMS,main="Normal Quantile Plot for normal distribution")
qqline(DMS$DMS)
# the z test is not default in R, so we will be loading an additional library to run this test
# You only need to run the following lines once.
install.packages('TeachingDemos')
library(TeachingDemos)
#the parameters are the same for the z.test as the t.test except # that now, you need to specify the population standard
# You only need to run the following lines once.
install.packages('TeachingDemos')
install.packages("TeachingDemos")
library(TeachingDemos)
#the parameters are the same for the z.test as the t.test except # that now, you need to specify the population standard
# deviation.
# x contains the data, stdev is the known standard deviation, alternative = "two.sided" indicates that this is a
# confidence interval vs. a bound
# we are going to use the same standard deviation for both tests.
z.test (x, stdev, alterative = "two.sided", conf.level = 0.95)
stdev =sd(DMS$DMS)
stdev
n
n
n
n
n
n
n
# d) Generate a 95% confidence interval for the mean DMS odor threshold among all beginning oenology students (t test).
# Parameters for t.test
# You always indicate confidence level, alpha = 1 – C
# possibilities for alternative are "two.sided" (confidence interval),
# "less" (upper confidence bound for one-sided test), "greater" (lower confidence bound for one-sided test)
t.test(DMS$DMS, conf.level=0.95, alternative = "two.sided")
#e) Generate a 95% confidence interval for the mean DMS odor threshold among all beginning oenology students (z test).
# the z test is not default in R, so we will be loading an additional library to run this test
# You only need to run the following lines once.
install.packages('TeachingDemos')
# the z test is not default in R, so we will be loading an additional library to run this test
# You only need to run the following lines once.
# install.packages('TeachingDemos')
# library(TeachingDemos)
#the parameters are the same for the z.test as the t.test except # that now, you need to specify the population standard
# deviation.
# x contains the data, stdev is the known standard deviation, alternative = "two.sided" indicates that this is a
# confidence interval vs. a bound
# we are going to use the same standard deviation for both tests.
z.test (x, stdev, alterative = "two.sided", conf.level = 0.95)
#the parameters are the same for the z.test as the t.test except # that now, you need to specify the population standard
# deviation.
# x contains the data, stdev is the known standard deviation, alternative = "two.sided" indicates that this is a
# confidence interval vs. a bound
# we are going to use the same standard deviation for both tests.
stdev = sd(DMS$DMS)
stdev
z.test (x, stdev, alterative = "two.sided", conf.level = 0.95)
# we are going to use the same standard deviation for both tests.
stdev = sd(DMS$DMS)
quit
quit
quit()
# install.packages('TeachingDemos')
# library(TeachingDemos)
#the parameters are the same for the z.test as the t.test except # that now, you need to specify the population standard
# deviation.
# x contains the data, stdev is the known standard deviation, alternative = "two.sided" indicates that this is a
# confidence interval vs. a bound
# we are going to use the same standard deviation for both tests.
stdev = sd(DMS$DMS)
stdev
z.test (x, stdev, alterative = "two.sided", conf.level = 0.95)
# we are going to use the same standard deviation for both tests.
stdev = sd(DMS$DMS)
stdev
#z.test (x, stdev, alterative = "two.sided", conf.level = 0.95)
z.test(DMS$DMS, conf.level = 0.95, alternative="two.sided", sd=stdev)
attach(mtcars)
par(mfrow=c(1,2))   # two plots together
data.vec <- rnorm(40,mean=0,sd=1)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
# print(n, m, std)
str = sprintf("n = %d, mean = %f, std = %f, sample std = %f", n,m, std, std*sqrt(n))
print(str)
# windows()#this is optional
hist(avg, xlab="Data from Normal Distribution", freq = FALSE, main=sprintf("Histogram for Normal, n = %d",n))
curve(dnorm(x, mean=m, sd=std), col="blue", lwd=2, add=TRUE)
lines(density(avg, adjust=1),col = "red", lwd=2)
# windows()
# quartz()
qqnorm(avg,main=sprintf("Normal Quantile Plot for Normal, n = %d",n))
qqline(avg)
# A
for(i in 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
# print(n, m, std)
str = sprintf("n = %d, mean = %f, std = %f, sample std = %f", n,m, std, std*sqrt(n))
print(str)
# windows()#this is optional
hist(avg, xlab="Data from Normal Distribution", freq = FALSE, main=sprintf("Histogram for Normal, n = %d",n))
curve(dnorm(x, mean=m, sd=std), col="blue", lwd=2, add=TRUE)
lines(density(avg, adjust=1),col = "red", lwd=2)
# windows()
# quartz()
qqnorm(avg,main=sprintf("Normal Quantile Plot for Normal, n = %d",n))
qqline(avg)
quartz()
}
# A
for(i in 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
t.test(data.vec, conf.level=0.80, alternative = "two.sided")
}
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
t.test(data.vec, conf.level=0.80, alternative = "two.sided")
for(i in 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
t.test(data.vec, conf.level=0.80, alternative = "two.sided")
z.test(DMS$DMS, conf.level = 0.95, alternative="two.sided", sd=stdev)
}
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
t.test(data.vec, conf.level=0.80, alternative = "two.sided")
z.test(DMS$DMS, conf.level = 0.95, alternative="two.sided", sd=stdev)
m = mean(avg)
std = sd(avg)
t.test(data.vec, conf.level=0.80, alternative = "two.sided")
z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=stdev)
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
t.test(data.vec, conf.level=0.80, alternative = "two.sided")
z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=stdev)
for(i in 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std)
}
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std)
# A
for(30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std)
}
# A
for(i in 0:30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std)
}
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
print(z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std))
# A
while(i <= 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
print(z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std))
i<- i+1
}
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
print(z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std))
i<- i+1
# A
while(i <= 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
print(z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std))
i<- i+1
print(i)
}
# A
while(i <= 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
print(z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std))
i<- i+1
}
# A
i=0
while(i <= 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
print(z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std))
i<- i+1
}
# A
i=0
while(i < 30) {
data.vec <- rnorm(40,mean=10,sd=2)
data.mat <- matrix(data.vec, ncol = n)
avg <- apply(data.mat, 1, mean)
m = mean(avg)
std = sd(avg)
print(z.test(data.vec, conf.level = 0.80, alternative="two.sided", sd=std))
i<- i+1
}
# B
hogs=read.table(file="hogs.txt",header=T)
quartz()
hist(hogs,freq = FALSE)          # frequency should be false to get density curve.....
means <- mean(hogs)
std <- sd(hogs)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
# B
hogs=read.table(file="hogs.txt",header=T)
quartz()
hist(hogs,freq = FALSE)          # frequency should be false to get density curve.....
means <- mean(hogs)
print(means)
std <- sd(hogs)
# B
hogs=read.table(file="hogs.txt",header=T)
print(hogs)
quartz()
hist(hogs,freq = FALSE)          # frequency should be false to get density curve.....
# B
hogs=read.table(file="hogs.txt",header=T)
print(hogs$Weight.lb.)
quartz()
hist(hogs,freq = FALSE)          # frequency should be false to get density curve.....
means <- mean(hogs)
# B
hogs=read.table(file="hogs.txt",header=T)
print(hogs$Weight.lb.)
quartz()
hist(hogs$Weight.lb.,freq = FALSE)          # frequency should be false to get density curve.....
means <- mean(hogs$Weight.lb.)
print(means)
std <- sd(hogs$Weight.lb.)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(hogs$Weight.lb., adjust=2),col = "red", lwd=2)
mean(hogs$Weight.lb.)
sd(hogs$Weight.lb.)
# boxplot
quartz()
boxplot(hogs$Weight.lb.)
points(means, pch = 18)
#  b) Make a Normal quantile plot to confirm that there are no systematic departures from Normality.
quartz()
qqnorm(hogs$Weight.lb.,main="Normal Quantile Plot for normal distribution")
qqline(hogs$Weight.lb.)
t.test(hogs$Weight.lb., conf.level=0.95, alternative = "two.sided")
stdev = sd(hogs$Weight.lb.)
stdev
z.test(hogs$Weight.lb., conf.level = 0.95, alternative="two.sided", sd=stdev)
# B
hogs=read.table(file="hogs.txt",header=T)
print(hogs$Weight.lb.)
quartz()
hist(hogs$Weight.lb.,freq = FALSE)          # frequency should be false to get density curve.....
means <- mean(hogs$Weight.lb.)
print(means)
std <- sd(hogs$Weight.lb.)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(hogs$Weight.lb., adjust=2),col = "red", lwd=2)
mean(hogs$Weight.lb.)
sd(hogs$Weight.lb.)
# boxplot
quartz()
boxplot(hogs$Weight.lb.)
points(means, pch = 18)
#  b) Make a Normal quantile plot to confirm that there are no systematic departures from Normality.
quartz()
qqnorm(hogs$Weight.lb.,main="Normal Quantile Plot for normal distribution")
qqline(hogs$Weight.lb.)
t.test(hogs$Weight.lb., conf.level=0.95, alternative = "two.sided")
stdev = sd(hogs$Weight.lb.)
stdev
z.test(hogs$Weight.lb., conf.level = 0.95, alternative="two.sided", sd=stdev)
source('~/Desktop/Purdue/STAT350_R/STAT350/Labs/Lab5/condifenceInterval.R')
# B
hogs=read.table(file="hogs.txt",header=T)
hist(hogs$Weight.lb.,freq = FALSE)          # frequency should be false to get density curve.....
means <- mean(hogs$Weight.lb.)
print(means)
std <- sd(hogs$Weight.lb.)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(hogs$Weight.lb., adjust=2),col = "red", lwd=2)
mean(hogs$Weight.lb.)
# for DMS
#a)  Make a boxplot and histogram to verify that the distribution is roughly symmetric with no outliers.
DMS=read.table(file="DMS.txt",header=T)
# histogram
# View(DMS)
# attach(DMS$DMS)
# library(lattice) # histogram 加上lattice
quartz()
hist(DMS$DMS,freq = FALSE)          # frequency should be false to get density curve.....
means <- mean(DMS$DMS)
std <- sd(DMS$DMS)
curve(dnorm(x, mean=means, sd=std), col="blue", lwd=2, add=TRUE)   # normal distribution line
lines(density(DMS$DMS, adjust=2),col = "red", lwd=2)
mean(DMS$DMS)
sd(DMS$DMS)
# boxplot
quartz()
boxplot(DMS$DMS)
points(means, pch = 18)
#  b) Make a Normal quantile plot to confirm that there are no systematic departures from Normality.
quartz()
qqnorm(DMS$DMS,main="Normal Quantile Plot for normal distribution")
qqline(DMS$DMS)
# c) From your observations in parts a) and b), is it appropriate to use the t- procedure?
# Assuming that the sample is SRS,
# the only other assumption that is necessary is to be sure that the distribution is normal.
# Since the sample size is 10, we can not use CLT.
# However, from the normal quantile plot and the histogram,
# we can see that the distribution is approximately normal.
# Therefore, this assumption is met.
# d) Generate a 95% confidence interval for the mean DMS odor threshold among all beginning oenology students (t test).
# Parameters for t.test
# You always indicate confidence level, alpha = 1 – C
# possibilities for alternative are "two.sided" (confidence interval),
